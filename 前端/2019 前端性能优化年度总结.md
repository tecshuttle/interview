# 2019 前端性能优化年度总结

https://juejin.im/post/5c4418006fb9a049c043545e

### 起步：计划与指标

1. 建立性能评估规范

2. 目标：比你最快的竞争对手快至少 20%

3. 选择合适的指标

4. 在目标用户的典型设备上收集数据

5. 为测试设立“纯净”、“接近真实用户”的浏览器配置

6. 与团队其他成员分享这份清单

### 设置切实可行的目标

7. 100 毫秒响应时间，60 fps

8. 速度指数 < 1250，TTI（交互时间） < 5s（3G），关键文件大小 < 170KB（gzip 压缩后）

### 定义环境

9. 选择并设置你的构建工具

10. 默认使用渐进增强

11. 选择一个高性能基准

12. 评估每个框架以及它们的依赖项

13. 考虑使用 PRPL 模式以及应用程序 shell 架构

14. 你是否优化了各个 API 的性能？

15. 你会使用 AMP 或 Instant Articles 吗？

16. 明智地选择你的 CDN

### 资源优化

17. 使用 Brotli 或 Zopfli 来对纯文本进行压缩

18. 使用响应图像和 WebP

19. 图像的优化是否得当

20. 视频优化是否得当

21. Web 字体优化过了么

### 构建优化

22. 确定优先级

23. 重温优秀的“符合最低要求”技术

24. 解析 JavaScript 是耗时的，所以让它体积小

25. 使用了摇树、作用域提升和代码分割吗

26. 可以将 JavaScript 切换到 Web Worker 中吗？

27. 可以将 JavaScript 切换到 WebAssembly 中吗？

28. 是否使用了 AOT 编译？

29. 仅将遗留代码提供给旧版浏览器

30. 是否使用了 JavaScript 差异化服务？

31. 通过增量解耦识别和重写遗留代码

32. 识别并删除未使用的 CSS/JS

33. 减小 JavaScript 包的大小

34. 是否使用了 JavaScript 代码块的预测预获取？

35. 从针对你的目标 JavaScript 引擎进行优化中获得好处

36. 使用客户端渲染还是服务器端渲染？

37. 约束第三方脚本的影响

38. 设置 HTTP 缓存标头

### 交付优化

39. 是否所有的 JavaScript 库都采用了异步加载？

40. 使用 IntersectionObserver 加载开销大的组件

41. 渐进式加载图片

42. 是否发送了关键的 css？

43. 尝试重组 CSS 规则

44. 有没有将请求设为 stream？

45. 考虑使组件具有连接感知能力

46. 考虑使组件具有设备内存感知能力

47. 做好连接的热身准备以加速交付

48. 使用 service workers 进行缓存和网络后备方案

49. 是否在 CDN/Edge 上使用了 service workers，例如，用于 A/B 测试？

50. 优化渲染性能

51. 是否优化了渲染体验？

### HTTP/2

52. 迁移到 HTTPS，然后启用 HTTP/2

53. 合适地部署 HTTP/2

54. 你的服务器和 CDN 支持 HTTP/2 吗？

55. OCSP Stapling 是否启用？

56. 你采用 IPv6 了吗？

57. 是否使用 HPACK 压缩？

58. 确保你的服务器安全稳固

### 测试和监控

59. 你优化过你的审计流程吗？

60. 你测试过代理和过时的浏览器吗？

61. 你测试过辅助工具的性能吗？

62. 是否设置了持续监控？