# 《Kubernetes in Action中文版》

## 1 Kubernetes介绍

1.1 Kubernetes 系统的需求 2
1.1.1 从单体应用到微服务 2
1.1.2 为应用程序提供一个一致的环境 5
1.1.3 迈向持续交付 ：DevOps 和无运维 6
1.2 介绍容器技术 7
1.2.1 什么是容器 7
1.2.2 Docker 容器平台介绍 11
1.2.3 rkt——一个 Docker 的替代方案 14
1.3 Kubernetes 介绍 15
1.3.1 初衷 15
1.3.2 深入浅出地了解 Kubernetes 15
1.3.3 Kubernetes 集群架构 17
1.3.4 在 Kubernetes 中运行应用 18
1.3.5 使用 Kubernetes 的好处 20
1.4 本章小结 22

## 2 开始使用Kubernetes和Docker

2.1 创建、运行及共享容器镜像 23
2.1.1 安装 Docker 并运行 Hello World 容器 24
2.1.2 创建一个简单的 Node.js 应用 26
2.1.3 为镜像创建 Dockerfile 27
2.1.4 构建容器镜像 27
2.1.5 运行容器镜像 30
2.1.6 探索运行容器的内部 31
2.1.7 停止和删除容器 32
2.1.8 向镜像仓库推送镜像 33
2.2 配置 Kubernetes 集群 34
2.2.1 用 Minikube 运行一个本地单节点 Kubernetes 集群 34
2.2.2 使用 Google Kubernetes Engine 托管 Kubernetes 集群 36
2.2.3 为 kubectl 配置别名和命令行补齐 39
2.3 在 Kubernetes 上运行第一个应用 40
2.3.1 部署 Node.js 应用 40
2.3.2 访问 Web 应用 43
2.3.3 系统的逻辑部分 45
2.3.4 水平伸缩应用 46
2.3.5 查看应用运行在哪个节点上 49
2.3.6 介绍 Kubernetes dashboard 50
2.4 本章小结 51

## 3 pod：运行于Kubernetes中的容器

3.1 介绍 pod 53
3.1.1 为何需要 pod 54
3.1.2 了解 pod 55
3.1.3 通过 pod 合理管理容器 56
3.2 以 YAML 或 JSON 描述文件创建 pod 58
3.2.1 检查现有 pod 的 YAML 描述文件 59
3.2.2 为 pod 创建一个简单的 YAML 描述文件 61
3.2.3 使用 kubectl create 来创建 pod 63
3.2.4 查看应用程序日志 64
3.2.5 向 pod 发送请求 65
3.3 使用标签组织 pod 66
3.3.1 介绍标签 66
3.3.2 创建 pod 时指定标签 67
3.3.3 修改现有 pod 的标签 68
3.4 通过标签选择器列出 pod 子集 69
3.4.1 使用标签选择器列出 pod 69
3.4.2 在标签选择器中使用多个条件 71
3.5 使用标签和选择器来约束 pod 调度 71
3.5.1 使用标签分类工作节点 72
3.5.2 将 pod 调度到特定节点 72
3.5.3 调度到一个特定节点 73
3.6 注解 pod 73
3.6.1 查找对象的注解 74
3.6.2 添加和修改注解 74
3.7 使用命名空间对资源进行分组 75
3.7.1 了解对命名空间的需求 75
3.7.2 发现其他命名空间及其 pod 75
3.7.3 创建一个命名空间 76
3.7.4 管理其他命名空间中的对象 77
3.7.5 命名空间提供的隔离 78
3.8 停止和移除 pod 78
3.8.1 按名称删除 pod 78
3.8.2 使用标签选择器删除 pod 79
3.8.3 通过删除整个命名空间来删除 pod 80
3.8.4 删除命名空间中的所有 pod，但保留命名空间 80
3.8.5 删除命名空间中的（几乎）所有资源 80
3.9 本章小结 81

## 4 副本机制和其他控制器：部署托管的pod

4.1 保持 pod 健康 84
4.1.1 介绍存活探针 84
4.1.2 创建基于 HTTP 的存活探针 85
4.1.3 使用存活探针 86
4.1.4 配置存活探针的附加属性 87
4.1.5 创建有效的存活探针 88
4.2 了解 ReplicationController 89
4.2.1 ReplicationController 的操作 90
4.2.2 创建一个 ReplicationController 92
4.2.3 使用 ReplicationController 94
4.2.4 将 pod 移入或移出 ReplicationController 的作用域 97
4.2.5 修改 pod 模板 100
4.2.6 水平缩放 pod 101
4.2.7 删除一个 ReplicationController 103
4.3 使用 ReplicaSet 而不是 ReplicationController 104
4.3.1 比较 ReplicaSet 和 ReplicationController 104
4.3.2 定义 ReplicaSet 105
4.3.3 创建和检查 ReplicaSet 106
4.3.4 使用 ReplicaSet 的更富表达力的标签选择器 106
4.3.5 ReplicaSet 小结 107
4.4 使用 DaemonSet 在每个节点上运行一个 pod 107
4.4.1 使用 DaemonSet 在每个节点上运行一个 pod 108
4.4.2 使用 DaemonSet 只在特定的节点上运行 pod 109
4.5 运行执行单个任务的 pod 112
4.5.1 介绍 Job 资源 112
4.5.2 定义 Job 资源 113
4.5.3 看 Job 运行一个 pod 114
4.5.4 在 Job 中运行多个 pod 实例 114
4.5.5 限制 Job pod 完成任务的时间 116
4.6 安排 Job 定期运行或在将来运行一次 116
4.6.1 创建一个 CronJob 116
4.6.2 了解计划任务的运行方式 118
4.7 本章小结 118

## 5 服务：让客户端发现pod并与之通信

pod的访问上的特点：

- pod是短暂的——它们随时会启动或者关闭。
- 客户端不能提前知道提供服务的pod的IP地址。
- 水平伸缩意味着有多个pod会提供相同的服务。

### 5.1 介绍服务

Kubernetes服务是一种为一组相同的pod提供单一不变的接入点的资源。当服务存在时，它的IP地址和端口不会改变。

5.1.1 创建服务 123

5.1.2 服务发现 129

### 5.2 连接集群外部的服务

Endpoint资源，不是让服务将连接理定向到集群中的pod，而是让它重定向到外部IP和端口。

5.2.1 介绍服务 endpoint 133
5.2.2 手动配置服务的 endpoint 133
5.2.3 为外部服务创建别名 135

### 5.3 将服务暴露给外部客户端

服务和Endpoint用于集群内服务如何被pod使用，但是，还需要向外部公开某些服务。

有几种方式可以在外部访问服务：

1. 将服务的类型设置成NodePort。
2. 将服务的类型设置成LoadBalance，它是NodePort类型的一种扩展。
3. 创建Ingress资源，这是一个完全不同的机制，通过一个IP地址公开多个服务。

5.3.1 使用 NodePort 类型的服务 137
5.3.2 通过负载均衡器将服务暴露出来 140
5.3.3 了解外部连接的特性 142

### 5.4 通过 Ingress 暴露服务

**为什么需要Ingress?**

一个重要的原因是每个LoadBalancer服务都需要自己的负载均衡器，以及独有的公有IP地址，而Ingress只需要一个公网IP就能为许多服务提供访问。当客户端向Ingress发送HTTP请求时，Ingress会根据请求的主机名和路径决定请求转发到的服务。

5.4.1 创建 Ingress 资源 145
5.4.2 通过 Ingress 访问服务 146
5.4.3 通过相同的 Ingress 暴露多个服务 147
5.4.4 配置 Ingress 处理 TLS 传输 149
5.5 pod 就绪后发出信号 150
5.5.1 介绍就绪探针 151
5.5.2 向 pod 添加就绪探针 152
5.5.3 了解就绪探针的实际作用 154
5.6 使用 headless 服务来发现独立的 pod 155
5.6.1 创建 headless 服务 156
5.6.2 通过 DNS 发现 pod 156
5.6.3 发现所有的 pod——包括未就绪的 pod 157
5.7 排除服务故障 158
5.8 本章小结 159

## 6 卷：将磁盘挂载到容器

6.1 介绍卷 162
6.1.1 卷的应用示例 162
6.1.2 介绍可用的卷类型 164
6.2 通过卷在容器之间共享数据 165
6.2.1 使用 emptyDir 卷 165
6.2.2 使用 Git 仓库作为存储卷 168
6.3 访问工作节点文件系统上的文件 171
6.3.1 介绍 hostPath 卷 171
6.3.2 检查使用 hostPath 卷的系统 pod 172
6.4 使用持久化存储 173
6.4.1 使用 GCE 持久磁盘作为 pod 存储卷 174
6.4.2 通过底层持久化存储使用其他类型的卷 177
6.5 从底层存储技术解耦 pod 179
6.5.1 介绍持久卷和持久卷声明 179
6.5.2 创建持久卷 180
6.5.3 通过创建持久卷声明来获取持久卷 182
6.5.4 在 pod 中使用持久卷声明 184
6.5.5 了解使用持久卷和持久卷声明的好处 185
6.5.6 回收持久卷 186
6.6 持久卷的动态卷配置 187
6.6.1 通过 StorageClass 资源定义可用存储类型 188
6.6.2 请求持久卷声明中的存储类 188
6.6.3 不指定存储类的动态配置 190
6.7 本章小结 193

## 7 ConfigMap和Secret：配置应用程序

7.1 配置容器化应用程序 195
7.2 向容器传递命令行参数 196
7.2.1 在 Docker 中定义命令与参数 196
7.2.2 在 Kubernetes 中覆盖命令和参数 199
7.3 为容器设置环境变量 200
7.3.1 在容器定义中指定环境变量 201
7.3.2 在环境变量值中引用其他环境变量 201
7.3.3 了解硬编码环境变量的不足之处 202
7.4 利用 ConfigMap 解耦配置 202
7.4.1 ConfigMap 介绍 202
7.4.2 创建 ConfigMap 203
7.4.3 给容器传递 ConfigMap 条目作为环境变量 206
7.4.4 一次性传递 ConfigMap 的所有条目作为环境变量 208
7.4.5 传递 ConfigMap 条目作为命令行参数 209
7.4.6 使用 configMap 卷将条目暴露为文件 210
7.4.7 更新应用配置且不重启应用程序 216
7.5 使用 Secret 给容器传递敏感数据 218
7.5.1 介绍 Secret 218
7.5.2 默认令牌 Secret 介绍 218
7.5.3 创建 Secret 220
7.5.4 对比 ConfigMap 与 Secret 221
7.5.5 在 pod 中使用 Secret 222
7.6 本章小结 228

## 8 从应用访问pod元数据以及其他资源

8.1 通过 Downward API 传递元数据 229
8.1.1 了解可用的元数据 230
8.1.2 通过环境变量暴露元数据 231
8.1.3 通过 downwardAPI 卷来传递元数据 234
8.2 与 Kubernetes API 服务器交互 237
8.2.1 探究 Kubernetes REST API 238
8.2.2 从 pod 内部与 API 服务器进行交互 242
8.2.3 通过 ambassador 容器简化与 API 服务器的交互 248
8.2.4 使用客户端库与 API 服务器交互 251
8.3 本章小结 253

## 9 Deployment：声明式地升级应用

9.1 更新运行在 pod 内的应用程序 256
9.1.1 删除旧版本 pod，使用新版本 pod 替换 257
9.1.2 先创建新 pod 再删除旧版本 pod 257
9.2 使用 ReplicationController 实现自动的滚动升级 259
9.2.1 运行第一个版本的应用 259
9.2.2 使用 kubectl 来执行滚动式升级 261
9.2.3 为什么 kubectl rolling-update 已经过时 265
9.3 使用 Deployment 声明式地升级应用 266
9.3.1 创建一个 Deployment 267
9.3.2 升级 Deployment 269
9.3.3 回滚 Deployment 273
9.3.4 控制滚动升级速率 276
9.3.5 暂停滚动升级 278
9.3.6 阻止出错版本的滚动升级 279
9.4 本章小结 284

## 10 StatefulSet：部署有状态的多副本应用

10.1 复制有状态 pod 285
10.1.1 运行每个实例都有单独存储的多副本 286
10.1.2 每个 pod 都提供稳定的标识 287
10.2 了解 Statefulset 289
10.2.1 对比 Statefulset 和 ReplicaSet 289
10.2.2 提供稳定的网络标识 290
10.2.3 为每个有状态实例提供稳定的专属存储 292
10.2.4 Statefulset 的保障 294
10.3 使用 Statefulset 295
10.3.1 创建应用和容器镜像 295
10.3.2 通过 Statefulset 部署应用 296
10.3.3 使用你的 pod 301
10.4 在 Statefulset 中发现伙伴节点 305
10.4.1 通过 DNS 实现伙伴间彼此发现 306
10.4.2 更新 Statefulset 308
10.4.3 尝试集群数据存储 309
10.5 了解 Statefulset 如何处理节点失效 310
10.5.1 模拟一个节点的网络断开 310
10.5.2 手动删除 pod 312
10.6 本章小结 313

## 11 了解Kubernetes机理

11.1 了解架构 315
11.1.1 Kubernetes 组件的分布式特性 316
11.1.2 Kubernetes 如何使用 etcd 318
11.1.3 API 服务器做了什么 322
11.1.4 API 服务器如何通知客户端资源变更 324
11.1.5 了解调度器 325
11.1.6 介绍控制器管理器中运行的控制器 327
11.1.7 Kubelet 做了什么 331
11.1.8 Kubernetes Service Proxy 的作用 332
11.1.9 介绍 Kubernetes 插件 333
11.1.10 总结概览 335
11.2 控制器如何协作 335
11.2.1 了解涉及哪些组件 335
11.2.2 事件链 336
11.2.3 观察集群事件 337
11.3 了解运行中的 pod 是什么 339
11.4 跨 pod 网络 340
11.4.1 网络应该是什么样的 340
11.4.2 深入了解网络工作原理 341
11.4.3 引入容器网络接口 343
11.5 服务是如何实现的 344
11.5.1 引入 kube-proxy 344
11.5.2 kube-proxy 如何使用 iptables 344
11.6 运行高可用集群 346
11.6.1 让你的应用变得高可用 346
11.6.2 让 Kubernetes 控制平面变得高可用 347
11.7 本章小结 350

## 12 Kubernetes API服务器的安全防护

12.1 了解认证机制 351
12.1.1 用户和组 352
12.1.2 ServiceAccount 介绍 353
12.1.3 创建 ServiceAccount 354
12.1.4 将 ServiceAccount 分配给 pod 356
12.2 通过基于角色的权限控制加强集群安全 358
12.2.1 介绍 RBAC 授权插件 359
12.2.2 介绍 RBAC 资源 360
12.2.3 使用 Role 和 RoleBinding 363
12.2.4 使用 ClusterRole 和 ClusterRoleBinding 367
12.2.5 了解默认的 ClusterRole 和 ClusterRoleBinding 376
12.2.6 理性地授予授权权限 379
12.3 本章小结 379

## 13 保障集群内节点和网络安全

13.1 在 pod 中使用宿主节点的 Linux 命名空间 381
13.1.1 在 pod 中使用宿主节点的网络命名空间 382
13.1.2 绑定宿主节点上的端口而不使用宿主节点的网络命名空间 383
13.1.3 使用宿主节点的 PID 与 IPC 命名空间 385
13.2 配置节点的安全上下文 386
13.2.1 使用指定用户运行容器 387
13.2.2 阻止容器以 root 用户运行 388
13.2.3 使用特权模式运行 pod 389
13.2.4 为容器单独添加内核功能 390
13.2.5 在容器中禁用内核功能 391
13.2.6 阻止对容器根文件系统的写入 392
13.2.7 容器使用不同用户运行时共享存储卷 394
13.3 限制 pod 使用安全相关的特性 396
13.3.1 PodSecurityPolicy 资源介绍 396
13.3.2 了解 runAsUser、 fsGroup 和 supplementalGroup 策略 398
13.3.3 配置允许、默认添加、禁止使用的内核功能 400
13.3.4 限制 pod 可以使用的存储卷类型 402
13.3.5 对不同的用户与组分配不同的 PodSecurityPolicy 402
13.4 隔离 pod 的网络 406
13.4.1 在一个命名空间中启用网络隔离 406
13.4.2 允许同一命名空间中的部分 pod 访问一个服务端 pod 407
13.4.3 在不同 Kubernetes 命名空间之间进行网络隔离 408
13.4.4 使用 CIDR 隔离网络 409
13.4.5 限制 pod 的对外访问流量 409
13.5 本章小结 410

## 14 计算资源管理

14.1 为 pod 中的容器申请资源 411
14.1.1 创建包含资源 requests 的 pod 412
14.1.2 资源 requests 如何影响调度 413
14.1.3 CPU requests 如何影响 CPU 时间分配 418
14.1.4 定义和申请自定义资源 418
14.2 限制容器的可用资源 419
14.2.1 设置容器可使用资源量的硬限制 419
14.2.2 超过 limits 421
14.2.3 容器中的应用如何看待 limits 422
14.3 了解 pod QoS 等级 423
14.3.1 定义 pod 的 QoS 等级 424
14.3.2 内存不足时哪个进程会被杀死 426
14.4 为命名空间中的 pod 设置默认的 requests 和 limits 427
14.4.1 LimitRange 资源简介 428
14.4.2 LimitRange 对象的创建 428
14.4.3 强制进行限制 430
14.4.4 应用资源 requests 和 limits 的默认值 430
14.5 限制命名空间中的可用资源总量 431
14.5.1 ResourceQuota 资源介绍 431
14.5.2 为持久化存储指定配额 434
14.5.3 限制可创建对象的个数 434
14.5.4 为特定的 pod 状态或者 QoS 等级指定配额 435
14.6 监控 pod 的资源使用量 436
14.6.1 收集、获取实际资源使用情况 437
14.6.2 保存并分析历史资源的使用统计信息 439
14.7 本章小结 442

## 15 自动横向伸缩pod与集群节点

15.1 pod 的横向自动伸缩 444
15.1.1 了解自动伸缩过程 444
15.1.2 基于 CPU 使用率进行自动伸缩 447
15.1.3 基于内存使用进行自动伸缩 453
15.1.4 基于其他自定义度量进行自动伸缩 453
15.1.5 确定哪些度量适合用于自动伸缩 456
15.1.6 缩容到 0 个副本 456
15.2 pod 的纵向自动伸缩 456
15.2.1 自动配置资源请求 457
15.2.2 修改运行中 pod 的资源请求 457
15.3 集群节点的横向伸缩 457
15.3.1 Cluster Autoscaler 介绍 457
15.3.2 启用 Cluster Autoscaler 459
15.3.3 限制集群缩容时的服务干扰 460
15.4 本章小结 461

## 16 高级调度

16.1 使用污点和容忍度阻止节点调度到特定节点 463
16.1.1 介绍污点和容忍度 464
16.1.2 在节点上添加自定义污点 466
16.1.3 在 pod 上添加污点容忍度 467
16.1.4 了解污点和污点容忍度的使用场景 467
16.2 使用节点亲缘性将 pod 调度到特定节点上 469
16.2.1 指定强制性节点亲缘性规则 470
16.2.2 调度 pod 时优先考虑某些节点 472
16.3 使用 pod 亲缘性与非亲缘性对 pod 进行协同部署 475
16.3.1 使用 pod 间亲缘性将多个 pod 部署在同一个节点上 475
16.3.2 将 pod 部署在同一机柜、可用性区域或者地理地域 478
16.3.3 表达 pod 亲缘性优先级取代强制性要求 479
16.3.4 利用 pod 的非亲缘性分开调度 pod 481
16.4 本章小结 483

## 17 开发应用的最佳实践

17.1 集中一切资源 486
17.2 了解 pod 的生命周期 487
17.2.1 应用必须预料到会被杀死或者重新调度 487
17.2.2 重新调度死亡的或者部分死亡的 pod 490
17.2.3 以固定顺序启动 pod 491
17.2.4 增加生命周期钩子 493
17.2.5 了解 pod 的关闭 497
17.3 确保所有的客户端请求都得到了妥善处理 500
17.3.1 在 pod 启动时避免客户端连接断开 500
17.3.2 在 pod 关闭时避免客户端连接断开 501
17.4 让应用在 Kubernetes 中方便运行和管理 505
17.4.1 构建可管理的容器镜像 505
17.4.2 合理地给镜像打标签，正确地使用 ImagePullPolicy 506
17.4.3 使用多维度而不是单维度的标签 506
17.4.4 通过注解描述每个资源 506
17.4.5 给进程终止提供更多的信息 507
17.4.6 处理应用日志 508
17.5 开发和测试的最佳实践 510
17.5.1 开发过程中在 Kubernetes 之外运行应用 510
17.5.2 在开发过程中使用 Minikube 512
17.5.3 发布版本和自动部署资源清单 513
17.5.4 使用 Ksonnet 作为编写 YAML/JSON manifest文件的额外选择 513
17.5.5 利用持续集成和持续交付 514
17.6 本章小结 515

## 18 Kubernetes应用扩展

18.1 定义自定义 API 对象 517
18.1.1 CustomResourceDefinitions 介绍 518
18.1.2 使用自定义控制器自动定制资源 522
18.1.3 验证自定义对象 526
18.1.4 为自定义对象提供自定义 API 服务器 527
18.2 使用 Kubernetes 服务目录扩展 Kubernetes 528
18.2.1 服务目录介绍 529
18.2.2 服务目录 API 服务器与控制器管理器介绍 530
18.2.3 Service 代理和 OpenServiceBroker API 530
18.2.4 提供服务与使用服务 533
18.2.5 解除绑定与取消配置 535
18.2.6 服务目录给我们带来了什么 535
18.3 基于 Kubernetes 搭建的平台 536
18.3.1 红帽 OpenShift 容器平台 536
18.3.2 Deis Workflow 与 Helm 539
18.4 本章小结 541

## 附录

在多个集群中使用 kubectl
使用 kubeadm 配置多节点集群
使用其他容器运行时
Cluster Federation