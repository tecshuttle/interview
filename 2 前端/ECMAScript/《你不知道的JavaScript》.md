# 上卷：作用域和闭包

## 前言

JavaScript作为一个语言来说，它总是成为大家批评的对象，部分原因是它有很多历史遗留问题，但主要原因是它的设计哲学有问题。就像Brendan Eich曾经说过的，JavaScript甚至连名字都给人一种“蠢弟弟”的感觉，就像是它更成熟的大哥Java的不完整版本。不过名字只不过是营销策略上的一个意外，这两个语言有许多本质上的区别。JavaScript和Java的关系，就像Carnival（嘉年华）和Car（汽车）的关系一样，八竿子打不着。

虽然JavaScript可能是最容易上手的语言之一，但是由于其本身的特殊性，相比其他语言，能真正掌握JavaScript的人比较少。

JavaScript语言本质上有许多复杂的概念，但是却用一种看起来比较简单的方式体现出来，比如回调函数，因此JavaScript开发者通常只是简单地使用这些特性，并不会关心语言内部的实现原理。

由于JavaScript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。



**小结**

*JavaScript非常特殊，只学一部分的话非常简单，但是想要完整地学习会很难（就算学到够用也不容易）。当开发者感到迷惑时，他们通常会责怪语言本身，而不是怪自己对语言缺乏了解。这个系列就是为了解决这个问题，让你打心眼儿里欣赏这门语言。*



## 序

你是否也曾对解答各种各样的为什么很上瘾？大多数孩子都会。事实上，这可能是孩子身上我最喜欢的地方——求知欲很强。

我每天从早到晚都在使用JavaScript，并且已经持续了好几年，但我真的了解它吗？答案是否定的。当然，我了解它的很多细节，并且经常阅读标准文档和邮件列表中的内容，但是了解的程度低于我内心那个六岁的孩子希望我达到的水平。

——Shane Hudson

https://shanehudson.net



## 第1章 作用域是什么

### 1 编译原理

### 2 理解作用域

**演员表**

```js
var a = 2;
```

**对话**

可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。”然而，这并不完全正确。

总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

**编译器有话说**

LHS（Left Hand Side）和RHS（Right Hand Side）的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。

**引擎和作用域的对话**

**小测验**



### 3 作用域嵌套

遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。



### 4 异常

ReferenceError是非常重要的异常类型。

ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。



### 5 小结



## 第2章 词法作用域

作用域共有两种主要的工作模式：

- 记法作用域：最普遍，被大多数编程语言所采用，本书对这种作用域进行深入讨论。
- 动态作用域：仍有一些编程语言在使用（比如Bash脚本、Perl中的一些模式等）。

### 1 词法阶段

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

后面会介绍一些欺骗词法作用域的方法，这些方法在词法分析器处理过后依然可以修改作用域，但是这种机制可能有点难以理解。事实上，让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践。

注意：这里所说的气泡是严格包含的。我们并不是在讨论文氏图这种可以跨越边界的气泡。换句话说，没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。



**查找**

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直至遇见第一个匹配的标识符为止。

词法作用域查找只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。

### 2 欺骗词法

eval



with



性能



### 3 小结

## 第3章 函数作用域和块作用域

### 1 函数中的作用域

### 2 隐藏内部实现

### 3 函数作用域

匿名和具名

立即执行函数表达式

### 4 块作用域

**with**



**try/catch**



**let**

垃圾收集

let循环



**const**





### 5 小结



## 第4章 提升

### 1 先有鸡还是先有蛋



### 2 编译器再度来袭



### 3 函数优先



### 4 小结



## 第5章 作用域闭包



### 1 启示



### 2 实质问题



### 3 现在我懂了



### 4 循环和闭包



### 5 模块

现代的模块机制



未来的模块机制



### 6 小结



## 附录A 动态作用域



## 附录B 块作用域的替代方案



## 附录C this词法



## 附录D 致谢



# 上卷：this和对象原型

## 序

## 第1章 关于this

### 1 为什么要用this

### 2 误解

指向自身

它的作用域

### 3 this到底是什么



### 4 小结





## 第2章 this全面解析



### 1 调用位置



### 2 绑定规则

默认绑定

隐式绑定

显式绑定

new绑定

### 3 优先级



### 4 绑定例外

被忽略的this

间接引用

软绑定

### 5 this词法



### 6 小结



## 第3章 对象

### 1 语法

### 2 类型

### 3 内容

**可计算属性名**

**属性与方法**

**数组**

**复制对象**

**属性描述符**

**不变性**

- 对象常量

- 禁止扩展

- 密封

- 冰结

**[[Get]]**

如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回undefined，而是会抛出一个ReferenceError异常。

仅通过返回值，你无法判断一个属性是存在并且持有一个undefined值，还是变量不存在，所以[[Get]]无法返回某个特定值而返回默认的undefined。



**[[Put]]**

**Getter和Setter**

**存在性**

枚举

### 4 遍历



### 5 小结



## 第4章 混合对象“类”

### 1 类理论

“类”设计模式

JavaScript中的“类”

### 2 类的机制

建造

构造函数

### 3 类的继承

多态

多重继承

### 4 混入

显式混入

隐式混入

### 5 小结



## 第5章 原型

### 1 [[Prototype]]

Object.prototype

属性设置和屏蔽

### 2 “类”

“类”函数

“构造函数”

技术

### 3 （原型）继承



### 4 对象关联

创建关联

关联关系是备用

### 5 小结



## 第6章 行为委托

### 1 面向委托的设计

类理论

委托理论

比较思维模型

### 2 类与对象

控件“类”

委托控件对象

### 3 更简洁的设计

### 4 更好的语法

### 5 内省

### 6 小结



## 附录A ES6中的Class



# 中卷：类型和语法



## 序



## 第1章 类型



### 1 类型



### 2 内置类型



### 3 值和类型

undefined 和undeclared

typeof Undeclared

### 4 小结



## 第2章 值



### 1 数组



### 2 字符串



### 3 数字

2.3.1 数字的语法  16
2.3.2 较小的数值  18
2.3.3 整数的安全范围  19
2.3.4 整数检测  20
2.3.5 32 位有符号整数  20

### 4 特殊数值

2.4.1 不是值的值  21
2.4.2 undefined  21
2.4.3 特殊的数字  23
2.4.4 特殊等式  27

### 5 值和引用



### 6 小结



## 第3章 原生函数

### 1 内部属性[[Class]]



### 2 封装对象包装



### 3 拆封



### 4 原生函数作为构造函数

3.4.1 Array(..)  37
3.4.2 Object(..)、Function(..) 和RegExp(..)  40
3.4.3 Date(..) 和Error(..)  41
3.4.4 Symbol(..)  42
3.4.5 原生原型  43

### 5 小结

## 第4章 强制类型转换

### 1 值类型转换

### 2 抽象值操作

4.2.1 ToString  48
4.2.2 ToNumber  52
4.2.3 ToBoolean  53

### 3 显式强制类型转换

4.3.1 字符串和数字之间的显式转换  57
4.3.2 显式解析数字字符串  62
4.3.3 显式转换为布尔值  65

### 4 隐式强制类型转换

4.4.1 隐式地简化  67
4.4.2 字符串和数字之间的隐式强制类型转换  68
4.4.3 布尔值到数字的隐式强制类型转换  71
4.4.4 隐式强制类型转换为布尔值  72
4.4.5 || 和&&  73
4.4.6 符号的强制类型转换  76

### 5 宽松相等和严格相等

4.5.1 相等比较操作的性能  77
4.5.2 抽象相等

### 6 抽象关系比较

### 7 小结

## 第5章 语法

### 1 语句和表达式

5.1.1 语句的结果值  93
5.1.2 表达式的副作用  95
5.1.3 上下文规则  99

### 2 运算符优先级

5.2.1 短路  107
5.2.2 更强的绑定  107
5.2.3 关联  108
5.2.4 释疑  110

### 3 自动分号

### 4 错误

### 5 函数参数

### 6 try..finally

### 7 switch

### 8 小结



## 附录A 混合环境JavaScript



# 中卷：异步和性能

## 序

## 第1章 异步：现在与将来

### 1 分块的程序

异步控制台

### 2 事件循环

### 3 并行线程

完整运行

### 4 并发

非交互

交互

协作

### 5 任务



### 6 语句顺序



### 7 小结

## 第2章 回调

### 1 continuation

### 2 顺序的大脑

执行与计划

嵌套回调与链式回调

### 3 信任问题

五个回调的故事

不只是别人的代码

### 4 尝试挽救回调



### 5 小结



## 第3章 Promise

### 1 什么是Promise

#### 未来值

现在值与将来值

Promise值

#### 完成事件

Promise“事件”

### 2 具有then方法的鸭子类型

### 3 Promise信任问题

#### 调用过早

#### 调用过晚

Promise调试技巧

#### 回调未调用

#### 调用次数过少或过多

#### 未能传递参数/环境值

#### 吞掉错误或异常

#### 是可信任的Promise吗

#### 建立信任

### 4 链式流

术语：决议、完成以及拒绝

### 5 错误处理

绝望的陷阱

处理未捕获的情况

成功的坑

### 6 Promise模式

#### Promise.all([..])

#### Promise.race([..])

超时竞赛

finally

#### all([..])和race([..])的变体

- none([..])
- any([..])
- first([..])
- last([..])

#### 并发迭代

### 7 Promise API概述

new Promise(..)构造器

Promise.resolve(..)和Promise.reject(..)

then(..)和catch(..)

Promise.all([..])和Promise.race([..])

### 8 Promise局限性

**顺序错误处理**

**单一值**

分裂值

展开/传递参数

**单决议**

**惯性**

**无法取消的Promise**

**Promise性能**

更多的工作，更多的保护。这些意味着Promise与不可信任的裸回调相比会更慢一些。这是显而易见的，也很容易理解。

在默认情况下，你应该在代码中使用它们，然后对你应用的热路径进行性能分析。Promise真的是性能瓶颈呢，还是只有理论上的性能下降呢？只有这样，具备了真实有效的性能测评，在这些识别出来的关键区域分离出Promise才是审慎负责的。

### 9 小结



## 第4章 生成器

### 1 打破完整运行

#### 输入和输出

#### 多个迭代器

### 2 生成器产生值

#### 生产者与迭代器

#### iterable

#### 生成器迭代器

### 3 异步迭代生成器

### 4 生成器+Promise

#### 生成器中的Promise 并发

### 5 生成器委托

#### 为什么用委托

#### 消息委托

#### 异步委托

#### 递归委托

### 6 生成器并发

### 7 形实转换程序

### 8 ES6 之前的生成器

#### 手工变换

#### 自动转换

### 9 小结



## 第5章 程序性能

### 1 Web Worker

Web Worker是浏览器（即宿主环境）的功能，实际上和JavaScript语言本身几乎没什么关系。也就是说，JavaScript当前并没有任何支持多线程执行的功能。

#### Worker 环境

#### 数据传递

#### 共享Worker

#### 模拟Web Worker

### 2 SIMD

单指令多数据。

### 3 asm.js

asm.js（http://asmjs.org）这个标签是指JavaScript语言中可以高度优化的一个子集。通过小心避免某些难以优化的机制和模式（垃圾收集、类型强制转换，等等），asm.js风格的代码可以被JavaScript引擎识别并进行特别激进的底层优化。

#### 如何使用asm.js 优化

#### asm.js 模块

### 4 小结  298



## 第6章 性能测试与调优

### 1 性能测试

重复

Benchmark.js

### 2 环境为王

引擎优化

### 3 jsPerf.com

完整性检查

### 4 写好测试

### 5 微性能

不是所有的引擎都类似

大局

### 6.6 尾调用优化

### 6.7 小结



## 附录A asynquence 库



## 附录B 高级异步模式



# 下卷：起步上路

## 序

## 第1章 深入编程

1.1 代码 4
1.2 表达式 5
1.3 实践 6
1.3.1 输出 7
1.3.2 输入 8
1.4 运算符 9
1.5 值与类型 11
1.6 代码注释 13
1.7 变量 14
1.8 块 16
1.9 条件判断 17
1.10 循环 18
1.11 函数 20
1.12 实践 23
1.13 小结 25

## 第2章 深入JavaScript

2.1 值与类型 26
2.1.1 对象 28
2.1.2 内置类型方法 30
2.1.3 值的比较 31
2.2 变量 35
2.3 条件判断 37
2.4 严格模式 39
2.5 作为值的函数 40
2.5.1 立即调用函数表达式 41
2.5.2 闭包 42
2.6 this标识符 44
2.7 原型 46
2.8 旧与新 47
2.8.1 polyfilling 47
2.8.2 transpiling 48
2.9 非JavaScript 49
2.10 小结 50

## 第3章 深入“你不知道的JavaScript”系列

3.1 作用域和闭包 51
3.2 this和对象原型 52
3.3 类型和语法 53
3.4 异步和性能 53
3.5 ES6及更新版本 54
3.6 小结 55

# 下卷：ES6及更新版本

## 序

## 第1章 ES？现在与未来

1.1 版本 60
1.2 transpiling 61
1.3 小结 63

## 第2章 语法

2.1 块作用域声明 64
2.1.1 let声明 65
2.1.2 const声明 68
2.1.3 块作用域函数 70
2.2 spread/rest 71
2.3 默认参数值 73
2.4 解构 77
2.4.1 对象属性复制模式 78
2.4.2 不只是声明 79
2.4.3 重复赋值 81
2.5 太多，太少，刚刚好 83
2.5.1 默认值赋值 84
2.5.2 嵌套解构 84
2.5.3 解构参数 85
2.6 对象字面量扩展 90
2.6.1 简洁属性 90
2.6.2 简洁方法 90
2.6.3 计算属性名 95
2.6.4 设定[[Prototype]] 96
2.6.5 super对象 97
2.7 模板字面量 98
2.7.1 插入表达式 99
2.7.2 标签模板字面量 100
2.8 箭头函数 103
2.9 for..of循环 109
2.10 正则表达式 111
2.10.1 Unicode标识 111
2.10.2 定点标识 112
2.10.3 正则表达式flags 116
2.11 数字字面量扩展 117
2.12 Unicode 118
2.12.1 支持Unicode的字符串运算 119
2.12.2 字符定位 121
2.12.3 Unicode标识符名 123
2.13 符号 123
2.13.1 符号注册 125
2.13.2 作为对象属性的符号 127
2.14 小结 128

## 第3章 代码组织

3.1 迭代器 129
3.1.1 接口 130
3.1.2 next()迭代 131
3.1.3 可选的return(..)和throw(..) 132
3.1.4 迭代器循环 133
3.1.5 自定义迭代器 134
3.1.6 迭代器消耗 137
3.2 生成器 138
3.2.1 语法 139
3.2.2 迭代器控制 144
3.2.3 提前完成 147
3.2.4 错误处理 149
3.2.5 Transpile生成器 151
3.2.6 生成器使用 152
3.3 模块 153
3.3.1 旧方法 153
3.3.2 前进 154
3.3.3 新方法 156
3.3.4 模块依赖环 164
3.3.5 模块加载 166
3.4 类 167
3.4.1 class 168
3.4.2 extends和super 169
3.4.3 new.target 174
3.4.4 static 175
3.5 小结 176

## 第4章 异步流控制

4.1 Promise 177
4.1.1 构造和使用Promise 178
4.1.2 Thenable 180
4.1.3 Promise API 181
4.2 生成器 + Promise 183
4.3 小结 185

## 第5章 集合

5.1 TypedArray 187
5.1.1 大小端（Endianness） 188
5.1.2 多视图 189
5.1.3 带类数组构造器 190
5.2 Map 192
5.2.1 Map值 194
5.2.2 Map键 194
5.3 WeakMap 195
5.4 Set 196
5.5 WeakSet 198
5.6 小结 199

## 第6章 新增API

6.1 Array 200
6.1.1 静态函数Array.of(..) 200
6.1.2 静态函数Array.from(..) 201
6.1.3 创建数组和子类型 204
6.1.4 原型方法copyWithin(..) 205
6.1.5 原型方法fill(..) 206
6.1.6 原型方法find(..) 206
6.1.7 原型方法findIndex(..) 207
6.1.8 原型方法entries()、values()、keys() 208
6.2 Object 209
6.2.1 静态函数Object.is(..) 209
6.2.2 静态函数Object.getOwnPropertySymbols(..) 210
6.2.3 静态函数Object.setPrototypeOf(..) 210
6.2.4 静态函数Object.assign(..) 211
6.3 Math 212
6.4 Number 214
6.4.1 静态属性 214
6.4.2 静态函数Number.isNaN(..) 214
6.4.3 静态函数Number.isFinite(..) 215
6.4.4 整型相关静态函数 215
6.5 字符串 216
6.5.1 Unicode函数 217
6.5.2 静态函数String.raw(..) 217
6.5.3 原型函数repeat(..) 217
6.5.4 字符串检查函数 218
6.6 小结 218

## 第7章 元编程

7.1 函数名称 219
7.2 元属性 222
7.3 公开符号 223
7.3.1 Symbol.iterator 223
7.3.2 Symbol.toStringTag与Symbol.hasInstance 224
7.3.3 Symbol.species 225
7.3.4 Symbol.toPrimitive 226
7.3.5 正则表达式符号 226
7.3.6 Symbol.isConcatSpreadable 227
7.3.7 Symbol.unscopables 228
7.4 代理 228
7.4.1 代理局限性 231
7.4.2 可取消代理 232
7.4.3 使用代理 233
7.5 Reflect API 240
7.6 特性测试 243
7.7 尾递归调用（Tail Call Optimization,TCO） 245
7.7.1 尾调用重写 247
7.7.2 非TCO优化 248
7.7.3 元在何处 250
7.8 小结 251

## 第8章 ES6之后

8.1 异步函数 254
8.2 Object.observe(..) 257
8.2.1 自定义改变事件 258
8.2.2 结束观测 259
8.3 幂运算符 260
8.4 对象属性与... 260
8.5 Array#includes 261
8.6 SIMD 262
8.7 WebAssembly (WASM) 262
8.8 小结 264

