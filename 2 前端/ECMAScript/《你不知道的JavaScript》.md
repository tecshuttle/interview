# 上卷：作用域和闭包

## 前言

JavaScript作为一个语言来说，它总是成为大家批评的对象，部分原因是它有很多历史遗留问题，但主要原因是它的设计哲学有问题。就像Brendan Eich曾经说过的，JavaScript甚至连名字都给人一种“蠢弟弟”的感觉，就像是它更成熟的大哥Java的不完整版本。不过名字只不过是营销策略上的一个意外，这两个语言有许多本质上的区别。JavaScript和Java的关系，就像Carnival（嘉年华）和Car（汽车）的关系一样，八竿子打不着。

虽然JavaScript可能是最容易上手的语言之一，但是由于其本身的特殊性，相比其他语言，能真正掌握JavaScript的人比较少。

JavaScript语言本质上有许多复杂的概念，但是却用一种看起来比较简单的方式体现出来，比如回调函数，因此JavaScript开发者通常只是简单地使用这些特性，并不会关心语言内部的实现原理。

由于JavaScript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。



**小结**

JavaScript非常特殊，只学一部分的话非常简单，但是想要完整地学习会很难（就算学到够用也不容易）。当开发者感到迷惑时，他们通常会责怪语言本身，而不是怪自己对语言缺乏了解。这个系列就是为了解决这个问题，让你打心眼儿里欣赏这门语言。



## 序

你是否也曾对解答各种各样的为什么很上瘾？大多数孩子都会。事实上，这可能是孩子身上我最喜欢的地方——求知欲很强。

我每天从早到晚都在使用JavaScript，并且已经持续了好几年，但我真的了解它吗？答案是否定的。当然，我了解它的很多细节，并且经常阅读标准文档和邮件列表中的内容，但是了解的程度低于我内心那个六岁的孩子希望我达到的水平。

——Shane Hudson

https://shanehudson.net



## 第1章 作用域是什么

### 1 编译原理

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。

- 分词/词法分析（Tokenizing/Lexing）
- 解析/语法分析（Parsing）
- 代码生成

对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。

### 2 理解作用域

**演员表**

- 引擎
- 编译器
- 作用域

**对话**

```js
var a = 2;
```

可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。”然而，这并不完全正确。

总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

**编译器有话说**

当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。讲得更准确些，RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。

LHS（Left Hand Side）和RHS（Right Hand Side）的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。

**引擎和作用域的对话**


```js
function foo(a) {
  console.log( a ); // 2
}
foo( 2 );
```


让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。

引擎：我说作用域，我需要为foo进行 RHS 引用。你见过它吗？

作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个西数，给你。

引擎：哥们太够意思了！好吧，我来执行一下foo。

引擎：作用域，还有个事儿。我需要为日进行LHS 引用，这个你见过吗？

作用域：这个也见过，编译器最近把它声明为foo的一个形式参数了，拿去吧。

引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给。。

引擎：哥们，不好意思又来打扰你。我要为console 进行 RHS 引用，你见过它吗？

作用域：咱俩谁跟谁啊，再说我就是干这个的。这个我也有，console 是个内置对象。给你。

引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。

引擎：哥们，能帮我再找一下对日的RHS引用吗？虽然我记得它，但想再确认一次。

作用域：放心吧，这个变量没有变动过，拿走，不谢。

引擎：真棒。我来把a的值，也就是2，传递进1og(..)。

……

**小测验**

略。

### 3 作用域嵌套

遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

### 4 异常

为什么区分LHS和RHS是一件重要的事情？

```js
function foo(a) {
  console.log(a + b);
  b = a;
}

foo(2);
```

- 如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。
- 当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。

ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。



## 第2章 词法作用域

作用域共有两种主要的工作模式：

- 词法作用域：最普遍，被大多数编程语言所采用，本书对这种作用域进行深入讨论。
- 动态作用域：仍有一些编程语言在使用（比如Bash脚本、Perl中的一些模式等）。

### 1 词法阶段

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

后面会介绍一些欺骗词法作用域的方法，这些方法在词法分析器处理过后依然可以修改作用域，但是这种机制可能有点难以理解。事实上，让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践。

注意：这里所说的气泡是严格包含的。我们并不是在讨论文氏图这种可以跨越边界的气泡。换句话说，没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。

**查找**

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直至遇见第一个匹配的标识符为止。

词法作用域查找只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。

### 2 欺骗词法

**eval**

**with**

**性能**

### 3 小结



## 第3章 函数作用域和块作用域

究竟是什么生成了一个新的气泡？只有函数会生成新的气泡吗？JavaScript中的其他结构能生成作用域气泡吗？

### 1 函数中的作用域

对于前面提出的问题，最常见的答案是JavaScript具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及利用（事实上在嵌套的作用域中也可以使用）。

### 2 隐藏内部实现

#### 为什么“隐藏”变量和函数是一个有用的技术？

有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。设计良好的软件都会依此进行实现。

#### 规避冲突

“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

1. 全局命名空间：这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。
2. 模块管理：任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

### 3 函数作用域

匿名和具名

立即执行函数表达式

### 4 块作用域

表面上看JavaScript并没有块作用域的相关功能。除非你更加深入地研究。

**with**

**try/catch**

**let**

使用let进行的声明不会在块作用域中进行提升。

- 垃圾收集

- let循环

**const**

### 5 小结

函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{..}内部）。

从ES3 开始，try/catch 结构在 catch 分句中具有块作用域。

在ES6 中引人了 let 关键宇(var 关键宇的表亲），用来在任意代码块中声明变量。if(..) {let a = 2;} 会声明一个劫持了if 的{..}块的变量，并且将变量添加到这个块中。

有些人认为块作用域不应该完全作为函数作用城的替代方染。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。



## 第4章 提升

### 1 先有鸡还是先有蛋



### 2 编译器再度来袭



### 3 函数优先



### 4 小结

我们习惯将var a=2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a和a=2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。

这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。



## 第5章 作用域闭包

- 接下来的内容需要对作用域工作原理相关的基础知识有非常深入的理解。

- 我们将注意力转移到这门语言中一个非常重要但又难以掌握，近乎神话的概念上：闭包。

- 如果你了解了之前关于词法作用域的讨论，那么闭包的概念几乎是不言自明的。

### 1 启示

JavaScript中闭包无处不在，你只需要能够识别并拥抱它。

闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。

最后你恍然大悟：原来在我的代码中已经到处都是闭包了，现在我终于能理解它们了。

### 2 实质问题

```js
function foo() {
  var a = 2;
  
  function bar() {
    console.log(a);
  }
  
  return bar;
}

var baz = foo();
baz(); // 2 ——朋友，这就是闭包的效果。
```

在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的“神奇“之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是bar()本身在使用。

拜bar()所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时间进行引用。

bar()依然持有对该作用域的引用，而这个引用就叫作闭包。

### 3 现在我懂了

本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

### 4 循环和闭包



### 5 模块

现代的模块机制



未来的模块机制



### 6 小结



## 附录A 动态作用域



## 附录B 块作用域的替代方案



## 附录C this词法



## 附录D 致谢



# 上卷：this和对象原型

## 序

## 第1章 关于this

### 1 为什么要用this

### 2 误解

指向自身

它的作用域

### 3 this到底是什么



### 4 小结





## 第2章 this全面解析



### 1 调用位置



### 2 绑定规则

默认绑定

隐式绑定

显式绑定

new绑定

### 3 优先级



### 4 绑定例外

被忽略的this

间接引用

软绑定

### 5 this词法



### 6 小结



## 第3章 对象

### 1 语法

### 2 类型

### 3 内容

**可计算属性名**

**属性与方法**

**数组**

**复制对象**

**属性描述符**

**不变性**

- 对象常量

- 禁止扩展

- 密封

- 冰结

**[[Get]]**

如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回undefined，而是会抛出一个ReferenceError异常。

仅通过返回值，你无法判断一个属性是存在并且持有一个undefined值，还是变量不存在，所以[[Get]]无法返回某个特定值而返回默认的undefined。



**[[Put]]**

**Getter和Setter**

**存在性**

枚举

### 4 遍历



### 5 小结



## 第4章 混合对象“类”

### 1 类理论

“类”设计模式

JavaScript中的“类”

### 2 类的机制

建造

构造函数

### 3 类的继承

多态

多重继承

### 4 混入

显式混入

隐式混入

### 5 小结



## 第5章 原型

### 1 [[Prototype]]

Object.prototype

属性设置和屏蔽

### 2 “类”

“类”函数

“构造函数”

技术

### 3 （原型）继承



### 4 对象关联

创建关联

关联关系是备用

### 5 小结



## 第6章 行为委托

### 1 面向委托的设计

类理论

委托理论

比较思维模型

### 2 类与对象

控件“类”

委托控件对象

### 3 更简洁的设计

### 4 更好的语法

### 5 内省

### 6 小结



## 附录A ES6中的Class

class基本上只是现有[[Prototype]]（委托！）机制的一种语法糖。



# 中卷：类型和语法



## 序



## 第1章 类型



### 1 类型



### 2 内置类型



### 3 值和类型

undefined 和undeclared

typeof Undeclared

### 4 小结



## 第2章 值



### 1 数组



### 2 字符串



### 3 数字

2.3.1 数字的语法  16
2.3.2 较小的数值  18
2.3.3 整数的安全范围  19
2.3.4 整数检测  20
2.3.5 32 位有符号整数  20

### 4 特殊数值

2.4.1 不是值的值  21
2.4.2 undefined  21
2.4.3 特殊的数字  23
2.4.4 特殊等式  27

### 5 值和引用



### 6 小结



## 第3章 原生函数

### 1 内部属性[[Class]]



### 2 封装对象包装



### 3 拆封



### 4 原生函数作为构造函数

3.4.1 Array(..)  37
3.4.2 Object(..)、Function(..) 和RegExp(..)  40
3.4.3 Date(..) 和Error(..)  41
3.4.4 Symbol(..)  42
3.4.5 原生原型  43

### 5 小结

## 第4章 强制类型转换

### 1 值类型转换

### 2 抽象值操作

4.2.1 ToString  48
4.2.2 ToNumber  52
4.2.3 ToBoolean  53

### 3 显式强制类型转换

4.3.1 字符串和数字之间的显式转换  57
4.3.2 显式解析数字字符串  62
4.3.3 显式转换为布尔值  65

### 4 隐式强制类型转换

4.4.1 隐式地简化  67
4.4.2 字符串和数字之间的隐式强制类型转换  68
4.4.3 布尔值到数字的隐式强制类型转换  71
4.4.4 隐式强制类型转换为布尔值  72
4.4.5 || 和&&  73
4.4.6 符号的强制类型转换  76

### 5 宽松相等和严格相等

4.5.1 相等比较操作的性能  77
4.5.2 抽象相等

### 6 抽象关系比较

### 7 小结

## 第5章 语法

### 1 语句和表达式

5.1.1 语句的结果值  93
5.1.2 表达式的副作用  95
5.1.3 上下文规则  99

### 2 运算符优先级

5.2.1 短路  107
5.2.2 更强的绑定  107
5.2.3 关联  108
5.2.4 释疑  110

### 3 自动分号

### 4 错误

### 5 函数参数

### 6 try..finally

### 7 switch

### 8 小结



## 附录A 混合环境JavaScript



# 中卷：异步和性能

## 序

## 第1章 异步：现在与将来

### 1 分块的程序

异步控制台

### 2 事件循环

### 3 并行线程

完整运行

### 4 并发

非交互

交互

协作

### 5 任务



### 6 语句顺序



### 7 小结

## 第2章 回调

### 1 continuation

### 2 顺序的大脑

执行与计划

嵌套回调与链式回调

### 3 信任问题

五个回调的故事

不只是别人的代码

### 4 尝试挽救回调



### 5 小结



## 第3章 Promise

### 1 什么是Promise

#### 未来值

现在值与将来值

Promise值

#### 完成事件

Promise“事件”

### 2 具有then方法的鸭子类型

### 3 Promise信任问题

#### 调用过早

#### 调用过晚

Promise调试技巧

#### 回调未调用

#### 调用次数过少或过多

#### 未能传递参数/环境值

#### 吞掉错误或异常

#### 是可信任的Promise吗

#### 建立信任

### 4 链式流

术语：决议、完成以及拒绝

### 5 错误处理

绝望的陷阱

处理未捕获的情况

成功的坑

### 6 Promise模式

#### Promise.all([..])

#### Promise.race([..])

超时竞赛

finally

#### all([..])和race([..])的变体

- none([..])
- any([..])
- first([..])
- last([..])

#### 并发迭代

### 7 Promise API概述

new Promise(..)构造器

Promise.resolve(..)和Promise.reject(..)

then(..)和catch(..)

Promise.all([..])和Promise.race([..])

### 8 Promise局限性

**顺序错误处理**

**单一值**

分裂值

展开/传递参数

**单决议**

**惯性**

**无法取消的Promise**

**Promise性能**

更多的工作，更多的保护。这些意味着Promise与不可信任的裸回调相比会更慢一些。这是显而易见的，也很容易理解。

在默认情况下，你应该在代码中使用它们，然后对你应用的热路径进行性能分析。Promise真的是性能瓶颈呢，还是只有理论上的性能下降呢？只有这样，具备了真实有效的性能测评，在这些识别出来的关键区域分离出Promise才是审慎负责的。

### 9 小结



## 第4章 生成器

### 1 打破完整运行

#### 输入和输出

#### 多个迭代器

### 2 生成器产生值

#### 生产者与迭代器

#### iterable

#### 生成器迭代器

### 3 异步迭代生成器

### 4 生成器+Promise

#### 生成器中的Promise 并发

### 5 生成器委托

#### 为什么用委托

#### 消息委托

#### 异步委托

#### 递归委托

### 6 生成器并发

### 7 形实转换程序

### 8 ES6 之前的生成器

#### 手工变换

#### 自动转换

### 9 小结



## 第5章 程序性能

### 1 Web Worker

Web Worker是浏览器（即宿主环境）的功能，实际上和JavaScript语言本身几乎没什么关系。也就是说，JavaScript当前并没有任何支持多线程执行的功能。

#### Worker 环境

#### 数据传递

#### 共享Worker

#### 模拟Web Worker

### 2 SIMD

单指令多数据。

### 3 asm.js

asm.js（http://asmjs.org）这个标签是指JavaScript语言中可以高度优化的一个子集。通过小心避免某些难以优化的机制和模式（垃圾收集、类型强制转换，等等），asm.js风格的代码可以被JavaScript引擎识别并进行特别激进的底层优化。

#### 如何使用asm.js 优化

#### asm.js 模块

### 4 小结  298



## 第6章 性能测试与调优

### 1 性能测试

重复

Benchmark.js

### 2 环境为王

引擎优化

### 3 jsPerf.com

完整性检查

### 4 写好测试

### 5 微性能

不是所有的引擎都类似

大局

### 6.6 尾调用优化

### 6.7 小结



## 附录A asynquence 库



## 附录B 高级异步模式



# 下卷：起步上路

## 序

## 第1章 深入编程

1.1 代码 4
1.2 表达式 5
1.3 实践 6
1.3.1 输出 7
1.3.2 输入 8
1.4 运算符 9
1.5 值与类型 11
1.6 代码注释 13
1.7 变量 14
1.8 块 16
1.9 条件判断 17
1.10 循环 18
1.11 函数 20
1.12 实践 23
1.13 小结 25

## 第2章 深入JavaScript

2.1 值与类型 26
2.1.1 对象 28
2.1.2 内置类型方法 30
2.1.3 值的比较 31
2.2 变量 35
2.3 条件判断 37
2.4 严格模式 39
2.5 作为值的函数 40
2.5.1 立即调用函数表达式 41
2.5.2 闭包 42
2.6 this标识符 44
2.7 原型 46
2.8 旧与新 47
2.8.1 polyfilling 47
2.8.2 transpiling 48
2.9 非JavaScript 49
2.10 小结 50

## 第3章 深入“你不知道的JavaScript”系列

3.1 作用域和闭包 51
3.2 this和对象原型 52
3.3 类型和语法 53
3.4 异步和性能 53
3.5 ES6及更新版本 54
3.6 小结 55

# 下卷：ES6及更新版本

## 序

## 第1章 ES？现在与未来

1.1 版本 60
1.2 transpiling 61
1.3 小结 63

## 第2章 语法

2.1 块作用域声明 64
2.1.1 let声明 65
2.1.2 const声明 68
2.1.3 块作用域函数 70
2.2 spread/rest 71
2.3 默认参数值 73
2.4 解构 77
2.4.1 对象属性复制模式 78
2.4.2 不只是声明 79
2.4.3 重复赋值 81
2.5 太多，太少，刚刚好 83
2.5.1 默认值赋值 84
2.5.2 嵌套解构 84
2.5.3 解构参数 85
2.6 对象字面量扩展 90
2.6.1 简洁属性 90
2.6.2 简洁方法 90
2.6.3 计算属性名 95
2.6.4 设定[[Prototype]] 96
2.6.5 super对象 97
2.7 模板字面量 98
2.7.1 插入表达式 99
2.7.2 标签模板字面量 100
2.8 箭头函数 103
2.9 for..of循环 109
2.10 正则表达式 111
2.10.1 Unicode标识 111
2.10.2 定点标识 112
2.10.3 正则表达式flags 116
2.11 数字字面量扩展 117
2.12 Unicode 118
2.12.1 支持Unicode的字符串运算 119
2.12.2 字符定位 121
2.12.3 Unicode标识符名 123
2.13 符号 123
2.13.1 符号注册 125
2.13.2 作为对象属性的符号 127
2.14 小结 128

## 第3章 代码组织

3.1 迭代器 129
3.1.1 接口 130
3.1.2 next()迭代 131
3.1.3 可选的return(..)和throw(..) 132
3.1.4 迭代器循环 133
3.1.5 自定义迭代器 134
3.1.6 迭代器消耗 137
3.2 生成器 138
3.2.1 语法 139
3.2.2 迭代器控制 144
3.2.3 提前完成 147
3.2.4 错误处理 149
3.2.5 Transpile生成器 151
3.2.6 生成器使用 152
3.3 模块 153
3.3.1 旧方法 153
3.3.2 前进 154
3.3.3 新方法 156
3.3.4 模块依赖环 164
3.3.5 模块加载 166
3.4 类 167
3.4.1 class 168
3.4.2 extends和super 169
3.4.3 new.target 174
3.4.4 static 175
3.5 小结 176

## 第4章 异步流控制

4.1 Promise 177
4.1.1 构造和使用Promise 178
4.1.2 Thenable 180
4.1.3 Promise API 181
4.2 生成器 + Promise 183
4.3 小结 185

## 第5章 集合

5.1 TypedArray 187
5.1.1 大小端（Endianness） 188
5.1.2 多视图 189
5.1.3 带类数组构造器 190
5.2 Map 192
5.2.1 Map值 194
5.2.2 Map键 194
5.3 WeakMap 195
5.4 Set 196
5.5 WeakSet 198
5.6 小结 199

## 第6章 新增API

6.1 Array 200
6.1.1 静态函数Array.of(..) 200
6.1.2 静态函数Array.from(..) 201
6.1.3 创建数组和子类型 204
6.1.4 原型方法copyWithin(..) 205
6.1.5 原型方法fill(..) 206
6.1.6 原型方法find(..) 206
6.1.7 原型方法findIndex(..) 207
6.1.8 原型方法entries()、values()、keys() 208
6.2 Object 209
6.2.1 静态函数Object.is(..) 209
6.2.2 静态函数Object.getOwnPropertySymbols(..) 210
6.2.3 静态函数Object.setPrototypeOf(..) 210
6.2.4 静态函数Object.assign(..) 211
6.3 Math 212
6.4 Number 214
6.4.1 静态属性 214
6.4.2 静态函数Number.isNaN(..) 214
6.4.3 静态函数Number.isFinite(..) 215
6.4.4 整型相关静态函数 215
6.5 字符串 216
6.5.1 Unicode函数 217
6.5.2 静态函数String.raw(..) 217
6.5.3 原型函数repeat(..) 217
6.5.4 字符串检查函数 218
6.6 小结 218

## 第7章 元编程

7.1 函数名称 219
7.2 元属性 222
7.3 公开符号 223
7.3.1 Symbol.iterator 223
7.3.2 Symbol.toStringTag与Symbol.hasInstance 224
7.3.3 Symbol.species 225
7.3.4 Symbol.toPrimitive 226
7.3.5 正则表达式符号 226
7.3.6 Symbol.isConcatSpreadable 227
7.3.7 Symbol.unscopables 228
7.4 代理 228
7.4.1 代理局限性 231
7.4.2 可取消代理 232
7.4.3 使用代理 233
7.5 Reflect API 240
7.6 特性测试 243
7.7 尾递归调用（Tail Call Optimization,TCO） 245
7.7.1 尾调用重写 247
7.7.2 非TCO优化 248
7.7.3 元在何处 250
7.8 小结 251

## 第8章 ES6之后

8.1 异步函数 254
8.2 Object.observe(..) 257
8.2.1 自定义改变事件 258
8.2.2 结束观测 259
8.3 幂运算符 260
8.4 对象属性与... 260
8.5 Array#includes 261
8.6 SIMD 262
8.7 WebAssembly (WASM) 262
8.8 小结 264

