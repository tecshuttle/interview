# 《JavaScript忍者秘籍（第2版）》

## 简介

本书通过4个部分，让你从“学徒”晋升为“忍者”。

**第1部分 介绍我们后续学习的主题和所需要的工具。**

第1章介绍JavaScript语言及最重要的特性，推荐目前我们开发应用时需要遵循的最佳实践，包括测试和性能分析。

因为我们对JavaScript的研究是基于浏览器上下文，因此在第2章中，我们介绍客户端Web应用的生命周期，这有助于我们理解在开发Web应用程序时JavaScript所扮演的角色。

**第2部分 重点关注JavaScript的核心支柱之一——函数。**

我们将研究为什么函数如此重要，函数之间的区别，以及定义和调用函数的细节内容。我们还将特别关注一个新的函数类型——生成器函数，它在处理异步代码时尤为有效。

第3章从彻底检查JavaScript函数的定义开始涉足基础语言，也许你会感到吃惊。预期中可能是把对象作为重点，但是，让我们充分理解函数、JavaScript函数式语言，从普通的JavaScript程序员升级为JavaScript“忍者”！
在第4章中，我们继续研究函数，深入研究函数调用的机制，以及隐式函数参数的来龙去脉。

关于函数的内容还没有结束，在第5章我们把讨论推向更高的一个层级，研究两个密切相关的概念——作用域和闭包。闭包是函数式编程中的关键概念，闭包允许更细粒度地控制程序中声明和创建的对象作用域范围。控制对象的作用域范围是“忍者”编写代码的关键因素。即使不阅读后续的章节（但我们希望大家不要停下来），编程水平也会比刚开始学习时提高很多。

在第6章中，我们通过一种全新的函数类型（生成器函数）和一个新的对象类型（promise）帮助我们处理异步代码，最后结束对函数的研究。我们还展示了如何结合generator与promise，优雅地处理异步代码。

**第3部分 研究JavaScript的第二支柱——对象。**

我们将彻底地探索JavaScript中的面向对象，研究如何保护对对象的访问，如何处理集合和正则表达式。

第7章阐述对象，彻底了解JavaScript中面向对象是如何工作的。此外，我们还将引入一个新的JavaScript关键字：class。其背后概念可能与你所期望的有所不同。

第8章继续探索对象，我们将学习使用多种不同的技术保护对对象的访问。

在第9章中，我们将特别关注JavaScript中几种不同类型的集合。数组，从JavaScript诞生起就是JavaScript的一部分，map和set是最近新加入JavaScript的集合类型。

第10章着重介绍正则表达式，正则表达式是经常被忽略的一项语言特性，但正确使用正则表达式，可以减少很多代码量。我们将学习如何构建和使用正则表达式，以及如何使用正则表达式及其相关方法，优雅地解决一些重复出现的问题。

在第11章中，我们将学习使用不同技术实现代码模块化：更小、相对松耦合的代码片段，以及改善代码的机构和组织方式。

**第4部分 研究JavaScript与Web页面的交互以及浏览器如何处理事件，最后结束本书。在结束之前的最后一个重要话题是跨浏览器开发。**

第12章研究如何通过DOM API 动态修改页面，如何处理元素属性、样式，以及一些重要的性能注意事项。

第13章讨论JavaScript的单线程执行模型的重要性，以及单线程执行模型对事件循环的影响。我们还将学习间隔定时器的工作原理，以及如何使用它们提高Web应用程序的性能。

第14章检查开发时主要关心的5项跨浏览器问题：浏览器缺陷、缺陷修复、外部代码、功能缺失和回归。讨论诸如特性模拟和对象检测等方法，有助于跨浏览器开发的挑战。

## 第 1部分 热身

### 第 1章 无处不在的JavaScript

“理解”JavaScript语言
理解浏览器
使用当前的最佳实践
提高跨平台开发能力

### 第2章 运行时的页面构建过程

- 浏览器是否总是会根据给定的HTML来渲染页面呢？

- Web实用一次能处理多少个事件？
- 为什么浏览器使用事件队列来处理事件？

#### 1 生命周期概览

1. 输入URL（或者单击链接）
2. 生成请求并发送至服务器
3. 执行某些动作或者获取某些资源：将响应发送回客户端
4. 处理HTML、CSS和JavaScript并构建结果页面
5. 监控事件队列，一次处理其中的一个事件
6. 与页面元素交互
7. 关闭Web页面

> 主要阶段是：页面构建和事件处理。

#### 2 页面构建阶段

##### 2.1 HTML解析和DOM构建

- 尽管DOM是根据HTML来创建的，两者紧密联系，但需要强调的是，它们两者并不相同。你可以把HTML代码看作浏览器页面UI构建初始DOM的蓝图。为了正确构建每个DOM，浏览器还会修复它在蓝图中发现的问题。

- 每当解析到脚本元素时，浏览器就会停止从HTML构建DOM，并开始执行JavaScript代码。

##### 2.2 执行JavaScript代码

- JavaScript引擎：
  - Firefox：Spidermonkey
  - Chrome和Opera：V8
  - Edge：Chakra

- JavaScript中的全局对象：浏览器暴露给JavaScript引擎的主要全局对象是window对象，它代表了包含着一个页面的窗口。全局window对象最重要的属性是document，它代表了当前页面的DOM。

- JavaScript代码的不同类型：包含在函数内的代码叫作**函数代码**，而在所有函数以外的代码叫作**全局代码**。全局代码由JavaScript引擎以一种直接的方式自动执行，每当遇到这样的代码就一行接一行地执行。

#### 3 事件处理

##### 3.1 事件处理器概览

- 浏览器执行环境的核心思想基于：同一时刻只能执行一个代码片段，即所谓的单线程执行模型。
- 所有已生成的事件（无论是用户生成的，例如鼠标移动或键盘按压；还是服务器生成的，例如Ajax事件）都会放在同一个事件队列中，以它们被浏览器检测到的顺序排列。
- 一次只能处理一个事件。
- 事件是异步的。

##### 3.2 注册事件处理器

##### 3.3 处理事件

由于单线程执行模型，同一时刻只能处理一个事件，任何后面的事件都只能在当前事件处理器完全结束执行后才能被处理！

#### 4 练习题

相比将事件处理器赋值给某个特定元素的属性，使用 `addEventListener` 方法来注册事件处理器的优势是什么？

## 第2部分 理解函数

### 第3章 新手的第一堂函数课：定义与参数

函数式的不同点到底是什么

函数作为对象的乐趣

函数定义

函数的实参和形参

### 第4章 函数进阶：理解函数调用

使用隐式函数参数
函数调用
解决函数上下文的问题

### 第5章 精通函数：闭包和作用域

理解闭包
使用闭包
通过执行上下文来跟踪代码
使用词法环境跟踪变量的作用域
理解JavaScript的变量类型
研究闭包的工作原理

### 第6章 未来的函数：生成器和promise

使用生成器和promise编写优雅的异步代码
使用生成器函数
使用promise
把生成器和promise相结合

## 第3部分 深入钻研对象，强化代码

### 第7章 面向对象与原型

理解原型
对象构造器与原型
实现继承
在ES6使用JavaScript的class

### 第8章 控制对象的访问

#### 1 使用getter与setter控制属性访问

##### 1.1 定义getter和setter

##### 1.2 使用getter与setter校验属性值

##### 1.3 使用getter与setter定义如何计算属性值

#### 2 使用代理控制访问

代理是ES6提出的。

可以将代理理解为通用化的setter和getter，代理更加强大，区别是每个setter与getter仅能控制单个对象属性，而代理可用于对象交互的能用处理，包括调用对象的方法。

过去使用setter与getter处理日志记录、数据校验、计算属性等操作，均可使用代理对它们进行处理。

##### 2.1 使用代理记录日志

##### 2.2 使用代理检测性能

##### 2.3 使用代理自动填充属性

##### 2.4 使用代理实现负数组索引

##### 2.5 代理的性能消耗

在Chrome浏览器，代理数组的执行时间大约为正常数组的50倍，在Firefox浏览器大约为20倍。

我们建议谨慎使用代理。尽管使用代理可以创造性地控制对象的访问，但是大量的控制操作将带来性能问题。可以在对性能不敏感的程序里使用代理，但是若要多次执行代码时仍然要小心谨慎。像往常一样，我们建议你彻底地测试代码的性能。

### 第9章 处理集合

数组
Map
Set

### 第10章 正则表达式

为什么需要正则表达式
正则表达式进阶
编译正则表达式
捕获匹配的片段
利用函数进行替换
使用正则表达式解决常见的问题

### 第11章 代码模块化

在JavaScript ES6之前的版本中模块化代码
ES6模块

## 第4部分 洞悉浏览器

### 第12章 DOM操作

向DOM中注入HTML
DOM的特性和属性
令人头疼的样式特性
避免布局抖动

### 第13章 历久弥新的事件

你知道吗？

- 为什么不能保证定时器回调的时机？
- 如果setInterval定时器每3ms执行一次，而事件处理程序需要运行16ms，那么定时器回调函数将被添加到微任务队列中多少次？
- 为什么事件处理程序的函数上下文有时与事件的目标不同？

#### 1 深入事件循环

事件循环基于两个基本原则：

- 一次处理一个任务；
- 一个任务开始后直到运行完成，不会被其他任务中断。

宏任务和微任务队列之间的区别：单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理。

##### 1.1 仅含宏任务的示例

##### 1.2 同时含有宏任务和微任务的示例

在两个宏任务之间，可以重新渲染页面，而在微任务执行之前不允许重新渲染页面。

#### 2 玩转计时器：延迟执行和间隔执行

计时器能延迟一段代码的执行，延迟时长**至少**是指定的时长（单位是ms）。无法确保计时器延迟的时间，理解这一点非常重要，在事件循环中需要处理非常多的任务。

##### 2.1 在事件循环中执行计时器

延迟执行与间隔执行的区别



##### 2.2 处理计算复杂度高的任务

#### 3 处理事件

##### 3.1 通过DOM代理事件

##### 3.2 自定义事件

### 第14章 跨浏览器开发技巧

#### 跨浏览器注意事项

#### 五大开发问题

1. 浏览器缺陷
2. 浏览器的缺陷修复
3. 外部代码
4. 浏览器回归
5. 浏览器缺失的功能

#### 实现策略

#### 减少假设

## 附录A ES6附加特性

## 附录B 测试与调试的武器

## 附录C 习题答案

